---
title: Использование машинного обучения для анализа временных рядов
author: admin
date: '2021-01-09'
slug: modeltime
categories: ["R"]
tags: ["R Markdown", "временные ряды", "машинное обучение"]
subtitle: 'прогнозирование временных рядов с помощью одновременного использования нескольких моделей в языке программирования R'
summary: 'Мы покажем некоторые примеры использования машинного обучения для моделирования и прогнозирования временных рядов на примере  библиотеки `modeltime`.'
authors: 
- admin
lastmod: '2021-01-09'
featured: yes
math: true
image:
  caption: ''
  focal_point: ''
  preview_only: yes
projects: []
---

Под временным рядом обычно понимается последовательность {$y_t$} значений переменной, которые принимают значения через определенные (обычно регулярные) значения времени $t$. Область применения временных рядов очень обширна, временные ряды используются в сейсмологии, метеорологии, экономике, при регистрации значений любых датчиков. Временным рядам посвящено большое количество литературы, в частности, работа с временными рядами в среде {{< icon name="r-project" pack="fab" >}} описана в монографиях [[Shumway & Stoffer](https://www.stat.pitt.edu/stoffer/tsa4/)], [[Hyndman & Athanasopoulos](https://otexts.com/fpp2/)] и [[Мастицкий](https://ranalytics.github.io/tsa-with-r/)]. 

В нашем случае, в качестве временных рядов рассматривается, например, количество пожаров, регистрируемых в сутки/неделю/месяц или уровень воды в реках. Мы покажем применение достаточно новой библиотеки `modeltime` для моделирования временных рядов с помощью методов машинного обучения. Основные преимущества данной библиотеки:

- использование современных алогритмов машинного обучения
- комбинирование нескольких алгоритмов для улучшения результата
- работа с несколькими моделями одновременно
- настройка гиперпараметров моделей

Библиотека `modeltime` интегрирована с библиотекой `tidymodels`, что позволяет рассматривать ее в рамках единой экосистемы алгоритмов машинного обучения, основанной на принципах *tidy data*. Узнать больше о библиотеке `tidymodels` можно на [сайте библиотеки](https://www.tidymodels.org/) и в новой книге [Kuhn & Silge](https://www.tmwr.org/).

# Установка библиотеки

Стабильную версию библиотеки можно установить из репозитория [CRAN](https://cran.r-project.org/web/packages/modeltime/index.html)
соответствующей командой:
```r
install.packages("modeltime")
```
или девелоперскую версию, доступню на [GitHub](https://business-science.github.io/modeltime/)
```r
remotes::install_github("business-science/modeltime")
```

# Исходные данные

Поключим небходимые библиотеки.

```{r warning=FALSE, message=FALSE}

library(readxl)
library(magrittr)
library(tidyverse)
library(lubridate)

library(tidymodels)
library(modeltime)
library(timetk)
```

Рассмотрим фондовые данные по гидрологии с данными по уровням воды в Российской Федерации за 2008-2015 года.
Загрузим данные с **GitHub**:

```{r warning=FALSE, message=FALSE}
url <- "https://raw.githubusercontent.com/materov/hydro_data/main/df_hydro.csv"

df_hydro <- readr::read_csv(url)
```

Исходные данные содержат `r format(nrow(df_hydro), big.mark = " ")` записей и имеют две переменных: `date` и `level`, отвечающих за дату наблюдения и уровень воды.

```{r warning=FALSE, message=FALSE}
df_hydro
```

Сформируем данные для временного ряда: рассмотрим максимальные значения разлива рек.

```{r warning=FALSE, message=FALSE}
fire_time_series_tbl <-
df_hydro %>% 
  group_by(date) %>% 
  summarise(value = max(level)) 
```

Преобразуем `date` в формат даты:

```{r warning=FALSE, message=FALSE}
fire_time_series_tbl$date %<>% as.Date()
```

Визуализируем получившийся временной ряд:

```r
fire_time_series_tbl %>% 
  ggplot(aes(x = date, y = value)) + geom_line()
```

![Исходный временной ряд](ts_filtered_ml_initial_blog.png)

Из графика видно, что временной ряд имеет периодический характер.

# Моделирование временных рядов

Весь поток операций в modeltime можно разбить на следующие 6 шагов, позволяющих выполнить:

1.	Сбор данных и разделение их на обучающую и тестовую выборки.
2.	Создание и подгонку **нескольких моделей**.
3.	Добавление подогнанных моделей в *таблицы моделей*.
4.	Калибровка моделей на тестовое множество.
5.	Выполнение прогноза для тестового множества и оценка точности.
6.	*Корректировку моделей* на полный набор данных и прогнозирование на будущие значения.

Кратко покажем реализацию этих шагов.

*Шаг 1.* Разбиение на обучающую и тестовую выборку можно делать либо указав временной параметр, либо процентные соотношения.

```{r warning=FALSE, message=FALSE}
# 1. Разделение выборки на обучающую и тестовую ------------------------------

splits <- fire_time_series_tbl %>%  
  rsample::initial_time_split(prop = 0.9)

# альтернативный вариант
# splits <- fire_time_series_tbl %>%
#   time_series_split(assess     = "2 months", 
#                     cumulative = TRUE)
```

```r
splits %>%
  tk_time_series_cv_plan() %>%
  plot_time_series_cv_plan(date, value, 
                           .interactive = FALSE) +
  labs(title = "Разделение временного ряда на обучающую и тестовую выборку",
       subtitle = "в качестве тестовой выборки рассмотрены 10% данных",
       color = "Выборка:") +
  scale_x_date(date_breaks = "12 months",
               date_labels = "%Y")
```

![Разделение временного ряда на обучающую и тестовую выборку](ts_ml_train_test_blog.png)

*Шаг 2.* Следующим этапом является создание и подгонка моделей. Ключевая особенность `modeltime` заключается в возможности *работы с несколькими моделями одновременно*. Это позволяет сравнивать модели, выбирая наилучшие результаты.
Вот некоторые стандартные модели встроенные в `modeltime` (полный список моделей, который постоянно дополняется, можно получить на [сайте библиотеки](https://business-science.github.io/modeltime/articles/modeltime-model-list.html)):

- **ARIMA**;
- линейная регрессия;
- экспоненциальное сглаживание;
- **Prophet**;
- **MARS** (*Multivariate Adaptive Regression Splines*);
- **Elastic Nets**;
- **Random Forest**.

Отметим, что `modeltime` позволяет комбинировать алгоритмы, улучшая их, например, в модели **Prophet** можно улучшить ошибки, используя известный алгоритм машинного обучения **XGBoost**, что дает новую модель, которая называется **Prophet Boost**.

Модели машинного обучения более сложны, чем автоматизированные модели. Эта сложность обычно требует *рабочего процесса* (иногда называемого *конвейером* в других языках программирования). Общий процесс протекает следующим образом:
-	Создание типа модели, так называемого **рецепта** (recipe) предварительной обработки используя `tidymodels`.
-	Создание спецификаций модели.
-	Использование рабочего процесса для объединения спецификаций модели, предобработки и подходящей модели.

Построим несколько моделей для данного временного ряда. 

1. Линейная регрессия:

```{r warning=FALSE, message=FALSE}
# 2. Создание и подгонка нескольких моделей ----------------------------------

# Модель 1: lm ----
# Линейная регрессия
model_fit_lm <- linear_reg() %>%
  set_engine("lm") %>%
  fit(value ~ as.numeric(date) + factor(month(date), ordered = FALSE),
      data = training(splits))
```

2. Классическая модель **ARIMA** с автоопределением параметров:

```{r warning=FALSE, message=FALSE}
# Модель 2: auto_arima ----
# ARIMA
model_fit_arima <- arima_reg() %>%
  set_engine(engine = "auto_arima") %>%
  fit(value ~ date, data = training(splits))
```

3. Модель **Prophet Boost**:

```{r warning=FALSE, message=FALSE}
# Модель 3: arima_boost ----
# ARIMA с бустингом (уменьшение ошибок) с помощью XGBoost
model_fit_arima_boosted <- arima_boost(
  min_n = 2,
  learn_rate = 0.015) %>%
  set_engine(engine = "auto_arima_xgboost") %>%
  fit(value ~ date + as.numeric(date) + 
        factor(month(date), ordered = F),
      data = training(splits))
```

4.

```{r warning=FALSE, message=FALSE}

```

5. 

```{r warning=FALSE, message=FALSE}

```

6. 

```{r warning=FALSE, message=FALSE}

```

7. 

```{r warning=FALSE, message=FALSE}

```

8. 

```{r warning=FALSE, message=FALSE}

```


*Шаг 3.* Модели прописываются и добавляются в единую *таблицу моделей*, в которой до включения можно настраивать параметры, а затем проходит их подгонка/масштабирование, проверка на соответствие и калибровка по отношению к тестовой выборке. Далее происходит оценка точности качества моделей на тестовой выборке используя различные показатели точности:
-	MAE – средняя абсолютная ошибка;
-	MAPE – средняя абсолютная процентная ошибка;
-	MASE – средняя абсолютная нормированная ошибка;
-	SMAPE – симметричная средняя абсолютная процентная ошибка;
-	RMSE – среднеквадратическая ошибка;
-	RSQ – показатель $R^2$.

*Шаг 4.* *Калибровка*, по сути, - это способ определения доверительных интервалов и метрик точности, при этом калибровочные данные - это спрогнозированные значения и невязки, которые вычисляются на основе данных вне выборки.

*Шаг 5.* Сформированные модели проверяются на тестовых данных и визуализируются.

Также, составляется таблица ошибок, использующая рассмотренные выше показатели точности, пример такого рода таблицы показан ниже.

*Шаг 6.* Заключительный этап состоит в том, чтобы скорректировать модели, распространить их на полный набор данных и спрогнозировать будущие значения. 

{{% alert note %}}
Как видно из предыдущего шага, не все модели в нашем случае имеют достаточно хорошие показатели ошибок (в частности, показатель $R^2$ должен быть близок к единице, остальные показатели должны быть чем меньше, тем лучше), модели 1-4 можно удалить из-за низкой точности.
{{% /alert %}}

# Заключение

Мы рассмотрели методы прогнозирования временных рядов на основе современных алгоритмов машинного обучения для составления гидрологического прогноза, что публикуется впервые в применении в вопросам природной и техносферной безопасности. Используя возможности языка программирования {{< icon name="r-project" pack="fab" >}} можно не только разрабатывать модели прогнозирования, но и в последующем делать на их основе актуальные аналитические веб-сервисы на основе **R Markdown** и **Shiny** для практического применения прогнозов, что представляется перспективным направлением.

Отметим, что для улучшения точности прогноза сильно неструктурированных данных, например, при отсутствии явно выраженных сезонных компонент, можно использовать для моделирования нейронные (как правило, RNN, LSTM или CNN) сети, однако это выходит за рамки настоящей статьи, и обучение нейронной сети – процесс гораздо более трудоемкий, чем рассмотренное в работе моделирование, что может оказаться неэффективным с точки зрения временных затрат.









